아이템67_최적화는 신중히 하라
--------

### 최적화 관련 격언 모음

##### - (맹목적인 어리석음을 포함해) 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨팅 죄악이 더 많다(심지어 효율을 높이지도 못하면서) - 윌리엄 울프


##### - (전체의 97% 정도인)자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다. - 도널드 크누스


##### - 최적화를 할때는 다음 두 규칙을 따르라.
##### 첫번째, 하지마라
##### 두번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화 되지 않은 해법을 찾을 때까지는 하지 마라. - M.A. 잭슨

### 빠른 프로그램보다는 좋은 프로그램을 작성하라.

- 좋은 프로그램이지만 원하는 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것이다.
  - 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다.
  - 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.
    
=> 구현상의 문제는 얼마든지 최적화 해결을 할 수 있지만 아키텍처의 결함은 시스템 전체를 다시 작성하지 않고는 해결하기 불가능하다. 
##### 설계 단계에서 성능을 반드시 염두해두자.
 
### 1. 성능을 제한하는 설계를 피하라.

ex) 완성 후 변경하기 어려운 설계 요소는 컴포넌트 끼리, 혹은 외부 시스템과의 소통방식, API 네트워크 프로토콜 등 외부 소통 방식이다. / 매핑 문제...

### 2. API를 설계할 때 성능에 주는 영향을 고려하라.

ex) 1. public 타입을 가변으로 만들면 불필요한 방어적 복사 유발 가능(아이템 50)

2. 컴포지션으로 해결할수 있는데 상속 방식으로 설계한 public 클래스는 상위클래스에 영원히 종속되며 성능 제약까지 받음(아이템 18)

3. 인터페이스도 있는데 굳이 구현 타입을 사용하는 것은 특정 구현체에 종속되어 나중에 더 나은 구현체를 사용하지 못함(아이템 64)

4. java.awt.Component 클래스의 getSize 메서드

예시)
```java
public abstract class Component implements ImageObserver, MenuContainer,
                                           Serializable
{
    public Dimension getSize() {
        return size();
    }

    @Deprecated
    public Dimension size() {
        return new Dimension(width, height); // 방어적 복사 수행 
    }
}
```
아래와 같이 Dimension을 가변으로 설계했기 때문에 getSize를 호출하는 모든 곳에서 Dimension 인스턴스를 새로 생성하고 있다. 요즘의 VM이라면 작은 객체를 몇 개 생성하는게 큰 부담은 아니지만, 수백만 개를 생성해야 한다면 성능에 영향을 줄 수도 있기 때문이다.

```java
public class Dimension extends Dimension2D
		implements java.io.Serializable {  // 불변이 아니다

    public int width;
    public int height;

    public void setSize(int width, int height) {
          this.width = width;
          this.height = height;
    }
}
```

5. 성능을 위해 API를 왜곡하는건 매우 안좋은 생각이다.

### 각각의 최적화 시도 전후로 성능을 측정하라.

jmh 같은 프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는데 도움을 준다.

가장 먼저 살펴볼것은, 개별 메서드의 소비 시간과 호출 횟수 같은 런타임 정보의 제공을 이용해서 알고리즘을 알맞게 골랐는지 확인하는 것이다. 알고리즘을 잘못 골랐다면 다른 저수준 최적화는 아무런 소용이 없어진다.

참고로 자바는 C/C++보다 성능 모델이 덜 정교하다. 프로그래머가 작성하는 코드와 CPU에서 수행하는 명령 사이의 '추상화 격차'가 크기 때문에 최적화로 인한 성능 변화를 일정하게 예측하기가 어렵기 때문이다.

# 정리 

좋은 프로그램을 작성하다 보면 성능은 따라오므로 빠른 프로그램을 작성하려 안달하지 않아도 된다. 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두해 두어야 한다. 시스템 구현을 다했다면 성능을 측정해보고 충분히 빠르지 않다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하자. 만족할 때까지 반복하고, 모든 변경 후에는 성능을 측정하라.
