## 아이템69: 예외는 진짜 예외 상황에서만 사용하라
#### 예외를 써서 루프를 종료하는 나쁜 예시
- 배열의 끝에 도달해 ArrayIndexOutBoundsException 예외가 발생하면서 종료
``` java
try {
  int i = 0;
  while (true)
    range[i++].climb();
} catch (ArrayIndexOutBoundsException e) {
}
```
#### 왜 저렇게 코딩했을까?
- JVM은 배열에 접근할 때마다 경계를 넘지 않는지 검사 함. 일반적인 반복문도 같은 로직
- 반복문에 명시하면 중복되는 작업을 하나 제거할 수 있으니 성능이 높아졌을 것이라 추론
#### 왜 잘못된 생각일까?
1. 예외는 예외 상황에 쓸 용도로 설계되었으므로 JVM 구현자 입장에서는 명확한 검사만큼 빠르게 만들어야 할 동기가 약함(최적화에 별로 신경 쓰지 않았을 가능성이 큼)
2. 코드를 try-catch 블록 안에 넣으면 JVM이 적용할 수 있는 최적화가 제한됨
3. 배열을 순회하는 표준 관용구(for, while)는 앞서 걱정한 중복 검사를 수행하지 않는다. JVM이 알아서 최적화해 없애줌
#### 가장 치명적인 문제
- 반복문 몸체에서 다른 이유로(예:다른 array를 사용했다던지) ArrayIndexOutBoundsException이 발생하면, 정상적으로 종료된줄 오해 할 수 있음

#### 상태 검사 메서드
- 특정 상태에서만 호출할 수 있는 '상태 의존적' 메서드를 제공하는 클래스는 '상태 검사' 메서드도 함께 제공해야 함
- 예: Iterator 인터페이스의 next(상태 의존적 메서드), hasNext(상태 검사 메서드)
``` java
for (Iterator<Foo> i = collection.iterator(); i.hasNext();) {
  Foo foo = i.next();
	...
}
```
- Iterator가 hasNext를 제공하지 않았을 경우
``` java
try {
  Iterator<Foo> i = collection.iterator();
  while(true) {
    Foo foo = i.next();
    ...
  }
} catch (NoSuchElementException e) {
}
```
#### 상태 검사 메서드 대신 사용할 수 있는 선택지
1. 빈 옵셔널: Optional.empty()
3. null 같은 특수한 값을 반환
#### 상태 검사 메서드, 옵셔널, 특정 값 중 하나를 선택하는 지침
1. 외부 동기화 없이 여러 스레드가 동시에 접근할 수 있거나 외부 요인으로 상태가 변할 수 있다면 옵셔널이나 특정 값을 사용. 상태 검사 메서드와 상태 의존적 메서드 호출 사이에 객체의 상태가 변할 수 있기 때문
2. 성능이 중요한 상황에서 상태 검사 메서드가 상태 의존적 메서드의 작업 일부를 중복 수행한다면 옵셔널이나 특정 값을 선택
3. 다른 모든 경우엔 상태 검사 메서드 방식이 조금 더 나음. 가독성이 살짝 더 좋고, 잘못 사용했을 때 발견하기 쉬움. 상태 검사 메서드 호출을 깜빡 잊었다면 상태 의존적 메서드가 예외를 던져 버그를 확실히 드러냄
### 결론
예외는 (그 이름이 말해주듯) 오직 예외 상황에서만 써야 함. 절대로 일살적인 제어 흐름용으로 쓰여선 안 됨.
