2장 객체 생성과 파괴
	아이템1 : 생성자 대신 정적 팩터리 메서드를 고려하라 
		ex)
			public static Boolean valueOf(boolean b){
				return b ? Boolean.TRUE : Boolean.FALSE;
			}
			
		* 장점
			장점(1) 이름을 가질 수 있다.
				생성자는 매개변수와 생성자 자체로는 객체 득성을 제대로 설명하지 못하지만 정적 팩터리 메소드는 이름만 잘 지으면 반환될 객체의 특성을 쉽게 묘사할 수 있다.
				ex) '값이 소수인 BigInteger를 반환한다는 의미'는 BigInteger(int, int, Random) 과 BigInteger.probablePrime 중에는 후자가 더 낫다.
				
			장점(2) 호출될 때마다 인스턴스를 새로 생성하지 않아도 된다.
				ex)Boolean.valueOf(boolean) 메서드는 객체를 아예 생성하지 않아 객체가 자주 요청되는 상황이면 성능이 향상됌
				
				인스턴스(instance)? => 객체 지향 프로그래밍(Object Oriented Programming)에서 class에 소속된 개별적인 객체를 말한다.
					클래스는 일종의 설계도, 클래스를 사용해 구체적인 제품을 만드는것이 인스턴스화다.
					ex) 붕어빵 기계에서 붕어빵 틀은 Class이고 붕어빵은 Object이다. 붕어빵이 만들어지는 과정이 인스턴스화이며
						틀을 이용해 만들어진 붕어빵들이 인스턴스이다.
					https://velog.io/@k7nsuy/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%EB%9E%80
				
			장정(3) 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
				자바8 저네는 인터페이스에 정적 메서드를 선언할 수 없어서 인터페이스 반환하는 정적 메서드가 필요하면 인스턴스화가 불가능한 동반 클래스(companion class)를
				만들어 그 안에 정의하는것이 관례 였다.
				
				인터페이스(interface)? => 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스.
					극단적으로 동일한 목적 하에 동일한 기능을 수행하게끔 강제하는것이 인터페이스의 역할이자 개념.
						=> 자바의 다형성을 이용하여 코드 수정을 줄이고 유지보수성을 높인다.
				https://limkydev.tistory.com/197
				다형성 : https://tecoble.techcourse.co.kr/post/2020-10-27-polymorphism/
			
			장점(4) 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
			
			장점(5) 정적 팩토리 메소드를 작성하는 시점에는 반활할 객체의 클래스가 존재하지 않아도 된다.
				대표적인 서비스 제공자 프레임워크로는 JDBC(Java Database Connectivity)
				
		* 단점
			단점(1) 상속을 하려면 public이나 protected 생성자가 필요하니 정적 펙토리 메소드만 제공하면 하위 클래스를 만들수 없다.
			
			단점(2) 정적 팩토리 메소드는 프로그래머가 찾기 힘들다.
				생성자처럼 API설명에 명확히 드러나지 않음.
			
		** 결론 => 장단점에 따라 정적 팩토리 메소드를 잘 사용하자.(무작정 Public 생성자 제공 보다는 낫다!)
		
	! 아이템2 : 생성자에 매개변수가 많다면 빌더를 고려하라
		- 매개변수가 많아지면 클라이언트 코드를 작성하거나 읽기 어려움.
		- 자바빈즈 패턴에서는 객체 하나를 만들려면 메소드를 여러개 호출해야되고 개게가 완전히 생성되지 전까지는 일관성(consistency)가 무너진 상태이다.
			=> 일관성이 무너지므로 클래스를 불변으로 만들 수 없다. 이는 Open-Closed Principle에 위배됌
			
			개방 폐쇄 원칙(OCP)? 
				=> 객체 지향 설계 5원칙 중 하나(S.O.L.I.D)
				기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계되어야 한다는 원칙.
				확장에 대해서는 개방적(open)이고, 수정에 대해서는 폐쇄적(closed)이어야 한다.
			
				객체 지향 설계 5원칙(S.O.L.I.D)
				SRP(Single Responsibility Principle): 단일 책임 원칙
				OCP(Open Closed Priciple): 개방 폐쇄 원칙
				LSP(Listov Substitution Priciple): 리스코프 치환 원칙
				ISP(Interface Segregation Principle): 인터페이스 분리 원칙
				DIP(Dependency Inversion Principle): 의존 역전 원칙
		
		** 결론 => 생성자나 정적 팩토리가 처리해야 할 매개변수가 많다면 빌더 패턴을 선택하는게 낫다.
			점층적 생성자보다 클라이언트 코드를 읽고 쓰기가 훨씬 간결하고, 자바빈즈 보다 훨씬 안전하다.
				
	아이템3 : private 생성자나 열거 타입으로 싱글턴임을 보증하라.
		(싱글턴을 private 생성자나 열거타입으로 보증하라는 뜻 같음) 
		싱글턴? => 인스턴스를 오직 하나만 생성할 수 있는 클래스를 말함.
		
		
	아이템4 : 인스턴스화를 막으려거든 private 생성자를 사용하라

	? 아이템5 : 자원을 직접 명시하지 말고 의존객체 주입을 사용하라
	
	! 아이템6 : 불 필요한 객체 생성을 피하라 
	
	! 아이템7 : 다 쓴 객체를 참조해제 하라 
	
	아이템8 : finalizer 와 cleaner 사용을 피하라
	
	? 아이템9 : try-finally 보다는 try-with-resources를 사용하라
		
