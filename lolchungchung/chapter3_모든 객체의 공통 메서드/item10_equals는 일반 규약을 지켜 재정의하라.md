# Item10 : equals는 일반 규약을 지켜 재정의 하라

### 목적 : equals를 재정의 하는 올바른 방법에 대해서.

equals 매서드를 재정의하는것은 쉬워보이지만 생각해야 할것이 많다.
아래 열거한 상황 중 하나라도 해당한다면 equals를 재정의 하지 않는것이 좋다.

1. 각 인스턴스가 본질적으로 고유하다. ??
	ex) Thread 
	
2. 인스턴스의 '논리적 동치성(logical equality)'을 검사할 일이 없다.
	논리적 동치성? => https://laurent.tistory.com/entry/%EC%9D%B4%EC%82%B0%EC%88%98%ED%95%99-%EB%85%BC%EB%A6%AC%EC%A0%81-%EB%8F%99%EC%B9%98-logical-equivalance
	
3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞는다.

4. 클래스가 private이거나 package-private이고 equals 매서드를 호출할 일이 없다.

그렇다면 equals를 재정의해야 할 때는?
객체 식별성(object identity; 두 객체가 물리적으로 같은지)가 아니라 논리적 동치성을 확인해야하는데 상위 클래스의 equals가 
논리적 동치성을 비교하도록 재정의 안됐을때(주로 Integer나 String 같은 값을 표현하는 클래스)

그러나 Enum 같이 값이 같은 인스턴스가 둘 이상 만들어지지 않게 보장하는 인스턴스 통제 클래스라면 equals 재정의 하지 않아도 된다.

equals의 메소드는 동치관계이며 다음을 만족한다.
1. 반사성 - null 이 아닌 모든 참조값 x에 대해  x.equlas(x)는 true
	객체는 자기 자신과 같아야 한다.
	
2. 대칭성 - null 이 아닌 모든 참조값 x,y에 대해 x.equals(y)가 true 면 y.equals(x)도 true
	두 객체는 서로에 대한 동치여부에 똑같이 답해야한다.
	ex) 코드 10-1, 대소문자 string 비교 예제
	
3. 추이성 - null 이 아닌 모든 참조값 x,y,z에 대해 x.equals(y)가 true고 y.equals(z)도 true 면 x.equals(z)도 true
	ex) point 와 colorPoint 예제

	! 구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.
	! 리스코프 치환 원칙
		자료형 B가 자료형 A의 서브타입라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 B의 객체를 자료형 A의 객체로 교체(치환)할 수 있어야 한다는 원칙이다. 
			=> 상속을 활용할 때 신중해야 한다.
			https://growing-dev101.tistory.com/entry/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-SOLID-%EC%9B%90%EC%B9%99
	
	! 구체 클래스의 하위 클래스에서 값을 추가할 방법을 우회하는 괜찮은 방법은 '상속 대신 컴포지션(조합)을 사용하는것'(Item18)
		자바라이브러리의 timeStamp 도 equals의 대칭성 위배하며  date 객체와 섞으면 엉뚱하게 동작함.
		

4. 일관성 - null 이 아닌 모든 참조값 x,y에 대해 x.quals(y)는 언제나 true거나 false 반환
	클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해서는 안됌.
	
	
5. null-아님 - null 이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false

동치관계란? 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산.


* 양질의 equals 메소드 구현 방법

1. == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.

2. instanceof 연산자로 입력이 올바른 타입인지 확인한다.

3. 입력을 올바른 타입으로 형변환한다. 

4. 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.

! 어떤 필드를 먼저 비교하느냐가 equals의 성능을 좌우하기도 한다.
	최상의 성능을 바란다면 다를 가능성이 더 크거나 비교하는 비용이 싼 필드를 먼저 비교한다.

5. equals를 다 구현했다면 세가지만 자문하자. 대칭적인가? 추이성이 있는가? 일관적인가? 
	꼭 단위테스트를 작성해서 돌려본다.
	
6. equals를 재정의할땐 hashCode도 반드시 재정의하자(Item11)

7. 너무 복잡하게 해결하려 들지 말자 
	필드들의 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있다.

8. Object 외의 타입을 매개변수로 받는 equals 매소드는 선언하지 말자.
	아닐경우는 재정의가 아닌 다중정의(Item52)이다.
	
구글이 만든 AutoValue 프레임워크를 활용하면 클래스에 애너테이션 하나만 추가하면 equals의 테스트를 대신해준다.
